/* They Didn't Include the automated source code appending like claude3 does so Since they are actually such an amazing utility and service Im personally
Giving Credits to them here for helping me Easily Convert A CommonJS Module from a Typescript Module.
Credits: https://js2ts.com/
This Entire Source Code was Originally Generated by js2ts with some minor Errors which needed adjustments AI is not perfect unless your Claude3 and even then Just like Humans AI can make mistakes
Hence why we should always test code rigorously so we don't make mistakes!
I Do Not Claim Authorship of this Code This code Was AI Generated and Human modified yes I Can Claim Authorship of what I Modified by I would personally wish not to so instead we will include there url in the author
Of our npm package to properly give credits for the typescript conversion!
and my works of testing and editing minor errors in AI generated code!
*/

import fs from 'node:fs';
import crypto from 'node:crypto';
import path from 'node:path';
import { EventEmitter } from 'node:stream';
import { spawn } from 'child_process';
import { ProcessEnvOptions } from 'node:child_process';

console.log('The God Box Simple Isolated Webserver Hosting Module In NodeJS!');
console.log('Prevent Path Traversal Exploits');
console.log('Prevents HTML Defacing By Replacing and Fixing! Until a Bug Fix can Be Released! To Stop the Exploit!');
console.log('Utilizes Simple Merkle Root Hash Verification Technique For Optimal Cpu Usage!');
console.log('Finalized Runtime Express Protection Middleware!');
console.log('Dual Express Protection Middleware Design Runtime/Physical File Protection');
console.log('Author: Johnathan Edward Brown, Mentor: Vampeyer');
console.log('I Hope you Enjoy My Nice Application Layer Security Tool For Express!');
/* These Interfaces Where Provided By Claude-3 To Solve And Keep the Config and envVar setup in the Godbox in the Typescript setup!*/
/* So we can Retain As Much as the original Source code as possible from the CommonJS module to a TypeScript module without Needing to majorly Restructure! */
/* I would be the only dumby to do something like this hence why I go by 2complexxx cause sometimes I just take the much more complicated ways to do things but today we stay simple dev!*/
interface EnvVar {
  name: string;
  value: string;
}

interface Config {
  envVars: { [key: string]: EnvVar };
}
/* End of Snippet of Code Provided By AI */
class GodBox {
    #fsMiddleware: boolean;
    #consoleOverride: { log: (...args: any[]) => void; time: (...args: any[]) => void; timeEnd: (...args: any[]) => void; error: (...args: any[]) => void; };
    #fsOverride: any;
    #devMode: boolean;
    #serverFile: string;
    #serverFolder: string;
    #interval: number;
    #merkleInterval: number;
    #useEnv: boolean;
    #GlobalReference: any;
    #sandbox: any;
    #context: any;
    #breakValue: boolean;
    #childEmitter: EventEmitter | undefined;
    #child: any;
    #childcwd: string | undefined;
    #childenv: any;
    #childServerFile: string | undefined;
    #childServerFolder: string | undefined;
    #timeOut: NodeJS.Timeout | undefined;
    #TheBox: GodBox;
    #TheProtectorO: any;
    #TrueSalt: Buffer;
    #TrueAnswer: any;
    #TrueAnswerLock: number;
    fileList: any[] = [];
    execList: any[] = [];
    #cwd: string;

    constructor(
      serverFile: string,
      serverFolder: string,
      interval: number,
      merkleInterval: number,
      useEnv: boolean = false,
      devMode: boolean = false,
      fsMiddleware: boolean,
      consoleOverride: { log: (...args: any[]) => void; time: (...args: any[]) => void; timeEnd: (...args: any[]) => void; error: (...args: any[]) => void; } = {
        log: console.log,
        time: console.time,
        timeEnd: console.timeEnd,
        error: console.error
      },
      fsOverride: any = {
        read: fs.read,
        readSync: fs.readSync,
        readFileSync: fs.readFileSync,
        cpSync: fs.cpSync,
        cp: fs.cp,
        rmSync: fs.rmSync,
        rm: fs.rm,          
        writeSync: fs.writeSync,
        write: fs.write,
        writeFile: fs.writeFile,
        writeFileSync: fs.writeFileSync,
        promises: {
          readdir: fs.promises.readdir,
          readFile: fs.promises.readFile,
          rm: fs.rmSync,
          cp: fs.cpSync,
          writeFile: fs.promises.writeFile,
        }
      }
    ) {
        this.#cwd = process.cwd();
        this.#breakValue = true;
        this.#devMode = devMode;
        this.#useEnv = useEnv;
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;
        this.#fsOverride = fsOverride;
        this.#fsMiddleware = fsMiddleware;
//        console = consoleOverride;
        this.#consoleOverride = consoleOverride;

        console.log = (...args: any[]) => {
          if (devMode) {
            originalConsoleLog(...args);
          } else {
            return;  
          }
        };
        console.error = (...args: any[]) => {
          if (devMode) {
            originalConsoleError(...args);
          } else {
            return;  
          }
        };

        const config = this.#generateConfig();
        Object.keys(process.env).forEach(key => {
          if (!config.envVars[key]) {
              delete process.env[key];
          }
        });
        this.#serverFile = serverFile;
        this.#serverFolder = serverFolder;
        this.#interval = interval;
        this.#merkleInterval = merkleInterval;
        this.#useEnv = useEnv;
        this.#TheBox = this;
        this.#TrueAnswerLock = 0;
        this.#TrueSalt = crypto.randomBytes(32);
        this.#runInVM(String(fs.readFileSync(path.join(process.cwd(), serverFile)).toString()), fs);

        let booleanCheck: boolean = false;

        process.on('SIGINT', async () => {
          if (!booleanCheck) {
            booleanCheck = true;
            this.#breakValue = false;
            this.#TheProtectorO.toggleLock();
            console.log('SIGINT Starting Shut Down Promise!');
            try {
              await new Promise<void>(async (resolve) => {
                try {
                  if (this.#childcwd) await fs.promises.rm(this.#childcwd, { recursive: true, retryDelay: 1000, maxRetries: 10, force: true });
                  console.log('SIGINT: Finished removing directory!');
                  resolve();
                } catch (err) {
                  resolve();
                }
              });

              this.stop();
              return process.exit(0);
            } catch (err) {
              console.log('Error on sigInt:', err);
            }
            return process.exit(0);
          }
        });

        process.on('SIGTERM', async () => {
          if (!booleanCheck) {
            booleanCheck = true;
            this.#breakValue = false;
            this.#TheProtectorO.toggleLock();
            console.log('SIGTERM Starting Shut Down Promise!');
            try {
              await new Promise<void>(async (resolve) => {
                try {
                  if (this.#childcwd) await fs.promises.rm(this.#childcwd, { recursive: true, retryDelay: 1000, maxRetries: 10 });
                  console.log('SIGTERM: Finished removing directory!');
                  resolve();
                } catch (err) {
                  console.log('Child closing Error:', err);
                  resolve();
                }
              });
              return process.exit(0);
            } catch (err) {
              console.log('Error on sigInt:', err);
            }
            return process.exit(0);
          }
        });
    }

    getGlobally() {
      return this.#GlobalReference;
    }

    #nonBlockingTimeout(ms: number): Promise<void> {
      return new Promise((resolve) => {
        setTimeout(resolve, ms);
      });
    }

    #generateConfig() {
      const config: Config = {
        envVars: {}
      };
      if (this.#useEnv) {
        const envContent = fs.readFileSync('.env', 'utf8');
        const envVars = envContent.split('\n')
            .filter(line => !line.startsWith('#'))
            .reduce<{ [key: string]: EnvVar }>((acc, line) => {
                const [key, value] = line.split('=');
                if (key && value) {
                    acc[key.trim()] = { name: key.trim(), value: value.replaceAll('"', '').trim() };
                }
                return acc;
            }, {});
        
        config.envVars = envVars;
    }
      return config;
    }

    #generateRandomFileName(length: number): string {
      return crypto.randomBytes(length).toString('hex');
    }

    #createCustomFork() {
      const child = spawn('node', []);
      this.#childenv = process.env;
      this.#childEmitter = new EventEmitter();
//      child.on = this.#childEmitter.on;
      child.emit = this.#childEmitter.emit;
      child.on('close', async () => {
        await new Promise<void>(async (resolve) => {
          try {
            if (this.#childcwd) await fs.promises.rm(this.#childcwd, { recursive: true, retryDelay: 1000, maxRetries: 10, force: true });
            console.log('Finished removing directory!');
            resolve();
          } catch (err) {
            console.log('Child closing Error:', err);
            resolve();
          }
        });
      });
      console.log('Creating Child Fork:', this.#childcwd, this.#childenv);
      return child;
    }

    async #generateNewChild() {
      const os = require('node:os');
      const path = require('node:path');
      const fs = require('node:fs');

      if (this.#childcwd) {
        try {
          await fs.promises.rm(this.#childcwd, { recursive: true, force: true });
        } catch (err) {
          console.log('Error removing child Directory:', err);
        }
        console.log('Finished removing directory!');
      }

      const randomFileName = this.#generateRandomFileName(16);
      const tempFilePath = `${os.tmpdir()}/${randomFileName}`;
      try {
        await fs.promises.cp(path.join(process.cwd()), path.join(tempFilePath), { recursive: true, force: true });
        console.log('Copying new child directory success!', tempFilePath);
      } catch (err) {
        console.log('Error copying new child:', err);
      }
      this.#childServerFile = path.join(tempFilePath, this.#serverFile);
      this.#childServerFolder = path.join(tempFilePath, this.#serverFolder);
      this.#childcwd = tempFilePath;
      await this.#nonBlockingTimeout(1000);
    }

    #obfuscateCode(code: string, devMode: boolean): string {
      const JavaScriptObfuscator = require('javascript-obfuscator');
      return JavaScriptObfuscator.obfuscate(code, {
        compact: true,
        controlFlowFlattening: false,
        deadCodeInjection: false,
        debugProtection: false,
        debugProtectionInterval: 0,
        disableConsoleOutput: !devMode,
        identifierNamesGenerator: 'hexadecimal',
        log: devMode,
        numbersToExpressions: false,
        renameGlobals: false,
        selfDefending: false,
        simplify: true,
        splitStrings: false,
        stringArray: true,
        stringArrayCallsTransform: false,
        stringArrayCallsTransformThreshold: 0.5,
        stringArrayEncoding: [],
        stringArrayIndexShift: true,
        stringArrayRotate: true,
        stringArrayShuffle: true,
        stringArrayWrappersCount: 1,
        stringArrayWrappersChainedCalls: true,
        stringArrayWrappersParametersMaxCount: 2,
        stringArrayWrappersType: 'variable',
        stringArrayThreshold: 0.75,
        unicodeEscapeSequence: false,
        reservedNames: ['process.*', 'pandoraWall', 'GLOBALLY', 'PandorasWall', 'PandorasWallSource']
      }).getObfuscatedCode();
    }

    async #runInVM(code: string, fs: any) {
      const os = require('node:os');
      const vm = require('node:vm');
      const path = require('node:path');
      if (this.#breakValue) {
        await this.#generateNewChild();
        this.#child = this.#createCustomFork();
        console.log('New Child: ', this.#child.killed, this.#childcwd);
        if (this.#childcwd) this.#TheProtectorO = this.#TheProtectorF(this.#serverFile, this.#serverFolder, this.#interval, this.#merkleInterval, this.#useEnv, this.#devMode, this.#fsMiddleware, this.#consoleOverride, this.#fsOverride, this.#childcwd, this.#TheBox);
        const GLOBALLY = this.#generateGlobal(this.#TheProtectorO);
        this.#GlobalReference = GLOBALLY;
        this.#TheProtectorO.setGlobal(this.#GlobalReference);
        const EMITTER = this.#childEmitter;
        const child = this.#child;
        this.#sandbox = {
          process: {
            process: this.#child,
            child: child,
            env: this.#childenv,
            cwd: this.#childcwd
          },
          fs,
          path,
          fetch,
          require,
          setTimeout,
          setInterval,
          clearInterval,
          clearTimeout,
          Buffer,
          global: {},
          GLOBALLY,
          EMITTER
        };
        if (this.#devMode) {
          this.#sandbox.console = console;
        }

        this.#sandbox.global = this.#sandbox;
        this.#context = vm.createContext(this.#sandbox);
        console.log('Starting context run!');
        const modifiedCode = `
          const crypto = require('crypto');

          function generateHash(input) {
              return crypto.createHash('sha256').update(input).digest('hex');
          }

          class PandorasWallSource {
              #middleBox;
              #privateBox;
              #publicBox;
              #scope;
              #masterBox;

              constructor(scope) {
                  this.#scope = scope;
                  this.#privateBox = this.#privateFunction(this);
                  this.#middleBox = this.#middle(this.#privateBox);
                  this.#publicBox = this.publicFunction(this.#middleBox);
                  process.child.on('exit', () => {
                    delete this;
                  });
              }

              publicFunction(middle) {
                  class ThePublicBox {
                      constructor(pandoraWall) {
                          function exampleCode() {
                              function outerFunction() {
                                  function innerFunction() {
                                      console.log('Inner function');
                                      ${code}
                                  }
                                  const innerAnonymous = function () {
                                      console.log('Anonymous function');
                                  };
                                  innerFunction();
                                  innerAnonymous();
                              }
                              outerFunction();
                          }
                          exampleCode();
                          process.child.on('exit', () => {
                            delete this;
                          });
                      }
                  }
                  return new ThePublicBox(middle);
              }

              #middle(a) {
                  class pandoraGlobal {
                      #booleanLock;
                      #booleanLock2;
                      GLOBAL_STRING;
                      #expressSymbol;
                      #expressLock;
                      #expressApp;
                      #Protect;

                      constructor(a) {
                          const crypto = require('node:crypto');
                          this.GLOBAL_STRING = crypto.randomBytes(2048).toString('base64') + crypto.randomBytes(4096).toString('hex') + crypto.randomBytes(2048).toString('base64');
                          this.#expressSymbol = Symbol(this.GLOBAL_STRING);
                          this.#expressLock = 0;
                          this.#Protect = a;
                      }

                      getGlobalString() {
                          return this.GLOBAL_STRING;
                      }

                      getGlobalSymbol() {
                          return this.#expressSymbol;
                      }

                      setExpress(app, box) {
                          function isExpressApp(obj, box) {
                              const isExpressAppSymbol = box.getGlobalSymbol();
                              return obj && obj[isExpressAppSymbol] === true;
                          }
                          console.log('Set express app called!');
                          if (this.#expressLock === 0 && isExpressApp(app, box)) {
                              this.#expressApp = app;
                              this.#expressLock = 1;
                              this.#expressProtect(app, box);
                          } else {
                              console.log('Malicious Activity Detected on the setExpressApp Call Please Double Check your Servers Code!');
                              return;
                          }
                      }

                      #expressProtect(app, JBGlobal) {
                          function isExpressApp(obj, JBGlobal) {
                              const isExpressAppSymbol = JBGlobal.getGlobalSymbol();
                              return obj && obj[isExpressAppSymbol] === true;
                          }

                          if (isExpressApp(app, JBGlobal)) {
                              console.log('Pandoras Wall: Success its a express application!');
                          } else {
                              console.log('Malicious Activity detected trying to set the express app in context to overwrite handlers!');
                              return;
                          }
                          console.log('Success!!!');
                          app.use((req, res, next) => {
                              switch (JBGlobal.getVerify()) {
                                  case 0:
                                      res.status(200).send(JSON.stringify({
                                          Error: 'Error please try again in like 1 second for the server to be refreshed!',
                                          Warning: 'Dont worry our Merkle Verification System is currently loading up requests are not allowed until verification!, You Are secure with us!'
                                      }));
                                      break;
                                  case 1:
                                      next();
                                      break;
                                  case 2:
                                      res.status(404).send(JSON.stringify({
                                          Error: 'Error please try again in like 1 second for the server to be refreshed!',
                                          Warning: 'Dont worry our Merkle Verification System has prevented some malicious Activity on our network, You Are secure with us!',
                                          Message: 'Our Merkle Verification System Deletes Malicous Modified Server Files and Replaces With Original Starts Back Up, So You can Be in peace of mind of your web application security.',
                                          Hackers: "Nice Try......"
                                      }));
                                  default:
                                      res.status(404).send(JSON.stringify({
                                          Error: 'Error please try again in like 1 second for the server to be refreshed!',
                                          Warning: 'Dont worry our Merkle Verification System has prevented some malicious Activity on our network, You Are secure with us!',
                                          Message: 'Our Merkle Verification System Deletes Malicous Modified Server Files and Replaces With Original Starts Back Up, So You can Be in peace of mind of your web application security.',
                                          Hackers: "Nice Try......"
                                      }));
                                      break;
                              }
                          });
                      }

                      getVerify() {
                          if (this.#Protect.verified === 2 || this.#Protect.verified2 === 2) {
                              return 2;
                          }
                          if (this.#Protect.verified === 1 || this.#Protect.verified2 === 1) {
                              return 1;
                          }
                          if (this.#Protect.verified === 0 || this.#Protect.verified2 === 0) {
                              return 0;
                          }
                      }
                  }
                  return new pandoraGlobal(a);
              }

              #privateFunction(box) {
                  class ThePrivateBox {
                      #rootMemoryHash;
                      #secondaryMemoryHash;
                      #currentMemoryHash;
                      #booleanLock;
                      #booleanASTLock;
                      #rootASTHash;
                      #currentASTHash;
                      #ASTInterval;
                      #MemoryInterval;
                      verified: number;
                      verified2: number;

                      constructor(scope, box) {
                          this.scope = scope;
                          this.verified = 0;
                          this.verified2 = 0;
                          this.#booleanLock = { lock: true };
                          this.#privateFunctionG(scope, this);
                          this.#rootASTHash = this.#exampleReverseTraverse(box);
                          this.#ASTInterval = setInterval(() => {
                              this.#currentASTHash = this.#exampleReverseTraverse(box);
                              if (this.#rootASTHash === this.#currentASTHash) {
                                  console.log('NO changes detected in AST!');
                                  this.verified2 = 1;
                              } else {
                                  console.log('WARNING WARNING WARNING YOU HAVE BEEN WARNED YOUR AST HAS DETECTED MODIFICATIONS TO THE RUNETIMES CODE!');
                                  console.log('LOCKING AST!');
                                  this.verified2 = 2;
                              }
                          }, 1000);

                          process.child.on('exit', () => {
                              console.log('Child Exiting From pandorasWall');
                              clearInterval(this.#ASTInterval);
                              clearInterval(this.#MemoryInterval);
                              delete this;
                          });
                      }

                      #exampleReverseTraverse(box) {
                          const crypto = require('crypto');

                          function generateHash(input) {
                              return crypto.createHash('sha256').update(input).digest('hex');
                          }

                          function reverseTraverseAndCapture(nodePath, localItems) {
                              let currentPath = nodePath;

                              while (currentPath && currentPath.node) {
                                  const node = currentPath.node;

                                  if (node.type === 'FunctionDeclaration') {
                                      localItems.add({
                                          type: 'FunctionDeclaration',
                                          name: node.id ? node.id.name : '<anonymous>',
                                          hash: generateHash(JSON.stringify(node)),
                                          node: currentPath,
                                      });
                                  } else if (node.type === 'FunctionExpression') {
                                      localItems.add({
                                          type: 'FunctionExpression',
                                          name: node.id ? node.id.name : '<anonymous>',
                                          hash: generateHash(JSON.stringify(node)),
                                          node: currentPath,
                                      });
                                  } else if (node.type === 'ArrowFunctionExpression') {
                                      localItems.add({
                                          type: 'ArrowFunctionExpression',
                                          name: '<anonymous>',
                                          hash: generateHash(JSON.stringify(node)),
                                          node: currentPath,
                                      });
                                  } else if (node.type === 'VariableDeclaration') {
                                      node.declarations.forEach(declaration => {
                                          if (declaration.id && declaration.id.name) {
                                              localItems.add({
                                                  type: 'VariableDeclaration',
                                                  name: declaration.id.name,
                                                  hash: generateHash(JSON.stringify(declaration)),
                                                  node: currentPath,
                                              });
                                          }
                                      });
                                  }

                                  currentPath = currentPath.parentPath;
                              }
                          }

                          const babelParser = require('@babel/parser');
                          const recast = require('recast');
                          const codeString = PandorasWallSource.toString();

                          const ast = babelParser.parse(codeString, {
                              sourceType: 'module',
                              plugins: ['classPrivateMethods', 'classPrivateProperties'],
                          });
                          const reverseLocalItems = new Set();

                          recast.types.visit(ast, {
                              visitFunctionDeclaration(path) {
                                  reverseTraverseAndCapture(path, reverseLocalItems);
                                  return false;
                              },

                              visitFunctionExpression(path) {
                                  reverseTraverseAndCapture(path, reverseLocalItems);
                                  return false;
                              },

                              visitArrowFunctionExpression(path) {
                                  reverseTraverseAndCapture(path, reverseLocalItems);
                                  return false;
                              },

                              visitVariableDeclaration(path) {
                                  path.node.declarations.forEach(declaration => {
                                      reverseTraverseAndCapture(path, reverseLocalItems);
                                  });
                                  return false;
                              }
                          });
                          const combinedHash = generateHash(Array.from(reverseLocalItems).toString());
                          return combinedHash;
                      }

                      #privateFunctionG(scope, box) {
                          const crypto = require('crypto');

                          function generateHash(input) {
                              return crypto.createHash('sha256').update(input).digest('hex');
                          }

                          function captureMemoryState() {
                              function hashObject(obj, visited = new Set(), depth = 0, maxDepth = 100000000) {
                                  if (obj === null || obj === undefined) return generateHash('null');

                                  const type = typeof obj;

                                  if (type === 'string' || type === 'number' || type === 'boolean') {
                                      return generateHash(obj.toString());
                                  }

                                  if (type === 'function') {
                                      return generateHash(obj.toString());
                                  }

                                  if (visited.has(obj)) {
                                      return generateHash('circular');
                                  }

                                  visited.add(obj);

                                  if (depth > maxDepth) {
                                      return generateHash('depth-exceeded');
                                  }

                                  if (Array.isArray(obj)) {
                                      return generateHash(obj.toString());
                                  }

                                  if (type === 'object') {
                                      return generateHash(obj.toString());
                                  }

                                  return generateHash('unknown');
                              }
                              const list = [hashObject(process), hashObject(global), hashObject(require)];
                              const finalHashes = hashObject(list);
                              return finalHashes;
                          }

                          function startMonitoring(box) {
                              box.#rootMemoryHash = captureMemoryState();
                              box.#MemoryInterval = setInterval(() => {
                                  box.#currentMemoryHash = captureMemoryState();
                                  if (box.#rootMemoryHash === box.#currentMemoryHash && box.#booleanLock.lock) {
                                      console.log('No Change Detected in Process Memory From Original Root Hash!');
                                      box.verified = 1;
                                  }

                                  if (box.#rootMemoryHash !== box.#currentMemoryHash && box.#booleanLock.lock) {
                                      box.#secondaryMemoryHash = box.#currentMemoryHash;
                                      box.#booleanLock.lock = false;
                                      box.verified = 2;
                                      console.log('Locking! Process has noticed a change in runtime Please be weary of this! if you didnt intentionally do this please pay CLOSE ATTENTION TO THIS CONSOLE LOG!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
                                  } else if (box.#secondaryMemoryHash !== box.#currentMemoryHash && !box.#booleanLock.lock) {
                                      box.verified = 2;
                                      console.log('Changes Detected in Process Memory! From Backup Secondary Hash WARNING THIS IS NOT GOOD! You have been warned!');
                                  } else if (box.#secondaryMemoryHash === box.#currentMemoryHash && !box.#booleanLock.lock) {
                                      box.verified = 2;
                                      console.log('No Changes Detected in Process Memory! From Backup Secondary Hash WARNING THIS IS NOT GOOD! You have been warned!');
                                  }
                              }, 1000);
                          }

                          process.child.on('uncaughtException', (err) => {
                              console.error('Unhandled Exception:', err);
                          });

                          process.child.on('unhandledRejection', (reason, promise) => {
                              console.error('Unhandled Rejection at:', promise, 'reason:', reason);
                          });

                          startMonitoring(box);
                      }
                  }
                  return new ThePrivateBox(this.#scope, box);
              }
          }
          new PandorasWallSource(this);
        `;
        const obfuscatedCode = this.#obfuscateCode(modifiedCode, this.#devMode);
        await this.#nonBlockingTimeout(1000);
        try {
          vm.runInContext(obfuscatedCode, this.#context);
        } catch (err) {
          console.log('Error:', err);
        }

        this.#timeOut = setTimeout(async () => {
          console.log('Stopping VM...');
          this.#rotateObby();
          await this.#nonBlockingTimeout(1000);
          this.#runInVM(code, fs);
        }, this.#interval);
      } else {
        return;
      }
    }

    #rotateObby() {
      this.#child.emit(this.#GlobalReference.getGlobalString());
      this.#child.kill();
      console.log('Child: ', this.#child.killed);
      console.log(this.#child.exitCode, 'Child exit code');
      this.#TheProtectorO.terminate();
      return;
    }

    #generateGlobal(theProtectorC: any) {
      class JBGlobal {
        #GLOBAL_STRING: string;
        #expressApp: any;
        #TheProtector: any;
        #maxHeaderSize: any;
        #maxBodySize: any;
        #expressSymbol: Symbol;
        #expressLock: Number;

        constructor(TheProtectorC: any) {
          const crypto = require('node:crypto');
          this.#GLOBAL_STRING = crypto.randomBytes(2048).toString('base64') + crypto.randomBytes(4096).toString('hex') + crypto.randomBytes(2048).toString('base64');
          this.#expressSymbol = Symbol(this.#GLOBAL_STRING);
          this.#TheProtector = theProtectorC;
          this.#expressLock = 0;
        }

        #generateRandomString(length: number): string {
          const letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
          const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_';
          let randomString = '';
          const firstCharIndex = Math.floor(Math.random() * letters.length);
          randomString += letters[firstCharIndex];
          for (let i = 1; i < length; i++) {
            const randomIndex = Math.floor(Math.random() * charset.length);
            randomString += charset[randomIndex];
          }
          return randomString;
        }

        getGlobalSymbol(): Symbol | symbol {
          return this.#expressSymbol;
        }

        getGlobalString(): string {
          return this.#GLOBAL_STRING;
        }

        setExpressApp(app: any, JBGlobal: any) {
          function isExpressApp(obj: any, JBGlobal: any) {
            const isExpressAppSymbol = JBGlobal.getGlobalSymbol();
            return obj && obj[isExpressAppSymbol] === true;
          }
          console.log('Set express app called!');
          if (this.#expressLock === 0 && isExpressApp(app, JBGlobal)) {
            this.#expressApp = app;
            this.#expressLock = 1;
            this.#expressProtect(app, JBGlobal);
          } else {
            console.log('Malicious Activity Detected on the setExpressApp Call Please Double Check your Servers Code!');
            return;
          }
        }

        #expressProtect(app: any, JBGlobal: any) {
          function isExpressApp(obj: any, JBGlobal: any) {
            const isExpressAppSymbol = JBGlobal.getGlobalSymbol();
            return obj && obj[isExpressAppSymbol] === true;
          }

          if (isExpressApp(app, JBGlobal)) {
            console.log('Success its a express application!');
          } else {
            console.log('Malicious Activity detected trying to set the express app in context to overwrite handlers!');
            return;
          }
          console.log('Success!!!');
          app.use((req: any, res: any, next: any) => {
            switch (JBGlobal.getMerkleVerify()) {
              case 0:
                res.status(200).send(JSON.stringify({
                  Error: 'Error please try again in like 1 second for the server to be refreshed!',
                  Warning: 'Dont worry our Merkle Verification System is currently loading up requests are not allowed until verification!, You Are secure with us!'
                }));
                break;
              case 1:
                next();
                break;
              case 2:
                res.status(404).send(JSON.stringify({
                  Error: 'Error please try again in like 1 second for the server to be refreshed!',
                  Warning: 'Dont worry our Merkle Verification System has prevented some malicious Activity on our network, You Are secure with us!',
                  Message: 'Our Merkle Verification System Deletes Malicous Modified Server Files and Replaces With Original Starts Back Up, So You can Be in peace of mind of your web application security.',
                  Hackers: "Nice Try......"
                }));
              default:
                res.status(404).send(JSON.stringify({
                  Error: 'Error please try again in like 1 second for the server to be refreshed!',
                  Warning: 'Dont worry our Merkle Verification System has prevented some malicious Activity on our network, You Are secure with us!',
                  Message: 'Our Merkle Verification System Deletes Malicous Modified Server Files and Replaces With Original Starts Back Up, So You can Be in peace of mind of your web application security.',
                  Hackers: "Nice Try......"
                }));
                break;
            }
          });

          app.use((req: any, res: any, next: any) => {
            const totalHeaderLength = Object.keys(req.headers).reduce((acc: number, header: string) => acc + header.length + req.headers[header].length, 0);
            if (totalHeaderLength > 8192) {
              return res.status(413).send('Request headers too large');
            }
            next();
          });

          function sanitizePath(req: any, res: any, next: any) {
            const path = require('node:path');
            const normalizedPath = path.normalize(req.path);
            req.sanitizedPath = normalizedPath;
            next();
          }
          app.use(sanitizePath);

          function sanitizeQueryParams(req: any, res: any, next: any) {
            const path = require('node:path');
            for (const key in req.query) {
              if (req.query.hasOwnProperty(key)) {
                req.query[key] = req.query[key].replace(/[\/\\]/g, '');
              }
            }
            next();
          }
          app.use(sanitizeQueryParams);
          console.log('Success!!!');
        }

        getMerkleVerify(): number {
          return this.#TheProtector.getMerkleVerify();
        }
      }
      return new JBGlobal(theProtectorC);
    }

    #TheProtectorF(serverFile: string, serverFolder: string, interval: number, merkleInterval: number, useEnv: boolean, devMode: boolean, fsMiddleware: boolean, consoleOverride: any, fsOverride: any, childCWD: string, theBox: any) {
      class TheProtectorC {
        #childcwd: string;
        #serverFile: string;
        #serverFolder: string;
        #interval: number;
        #useEnv: boolean;
        #theBox: any;
        #fileList: any[];
        #execList: any[];
        #answer: any;
        #timeOut: NodeJS.Timeout | undefined;

        #lock: boolean;
        #loopBreak: boolean;
        #lock3: boolean;
        #loops: number;

        #cwd: string;
        MerkleVerified: number;
        #JBGlobal: any;
        #executor: any;

        constructor(serverFile: string, serverFolder: string, interval: number, merkleInterval: number, useEnv: boolean, devMode: boolean, fsMiddleware: boolean, consoleOverride: any, fsOverride: any, childCWD: string, theBox: any) {
          const path = require('node:path');
          this.#fileList = [];
          this.#execList = [];
          this.#cwd = process.cwd();
          this.#serverFile = serverFile;
          this.#serverFolder = serverFolder;
          this.#interval = interval;
          this.#useEnv = useEnv;
          this.#childcwd = childCWD;
          this.#theBox = theBox;
          this.#lock = false;
          this.#loopBreak = false;
          this.#lock3 = false;
          this.MerkleVerified = 0;
          this.#loops = 0;
          this.#setup(serverFile, serverFolder, interval, useEnv);
        }

        getLock3(): boolean {
          return this.#lock3;
        }

        async #setup(serverFile: string, serverFolder: string, interval: number, useEnv: boolean) {
          const versionList = process.version.split(',');
          const v1 = parseInt(versionList[0].replace('v', ''));
          const v2 = parseInt(versionList[1]);
          console.log(versionList, v1, v2);

          function restart(this: any) {
            this.#theBox.restart(serverFile, serverFolder, interval, merkleInterval, useEnv, devMode, fsMiddleware, consoleOverride, fsOverride);
          }

          console.time('Timer');
          if (this.#theBox.#TrueAnswerLock === 0 && this.#lock === false && this.#loopBreak === false) {
            this.#lock = true;
            console.log('Setting up File Merkle Security!');
            if ((v1 === 19 && v2 >= 8) || v1 >= 20) {
              console.log('Node Version higher than 19.8.0 detected!');
              this.#theBox.#TrueAnswer = await this.#hashFolderContentsNodeV22(process.cwd());
            } else {
              console.log('Node Version lower than 19.8.0 detected! Please be aware this is a less optimized setup! Its recommended to utilize the Node v19.8.0 and up!');
              this.#theBox.#TrueAnswer = await this.#hashFolderContents(process.cwd());
            }
            this.#loopBreak = true;
            this.#theBox.#TrueAnswerLock = 1;
            console.log('File Merkle True Answer Calculated and Ready!');
            if (this.#loops <= 0) {
              this.#loops = this.#loops + 1;
              this.#timeOut = setInterval(async () => {
                console.log('File Merkle interval Started! Time Out Interval: 1');
                try {
                  if (this.#theBox.#TrueAnswer && this.#loopBreak === true && this.#lock === false) {
                    this.#lock = true;
                    console.log('Starting File calculations!');
                    console.time('Timer');
                    if ((v1 === 19 && v2 >= 8) || v1 >= 20) {
                      this.#answer = await this.#hashFolderContentsNodeV22(this.#childcwd);
                    } else {
                      this.#answer = await this.#hashFolderContents(this.#childcwd);
                    }
                    if (this.#answer.firstHash === this.#theBox.#TrueAnswer.firstHash) {
                      this.MerkleVerified = 1;
                      console.log('Verified File Merkle Success!');
                    } else if (this.#answer.firstHash !== this.#theBox.#TrueAnswer.firstHash) {
                      this.MerkleVerified = 2;
                      console.log('File Merkle Invalid warning restarting!');
                      this.#theBox.restart(serverFile, serverFolder, interval, merkleInterval, useEnv, devMode, fsMiddleware, consoleOverride, fsOverride);
                    }
                    this.#lock = false;
                    console.timeEnd('Timer');
                  } else if (this.#loopBreak === false) {
                    console.log('File Merkle Loop Is Breaking! If Server is not restarting please be warned malicious activity may be noticed!');
                    this.#loops = this.#loops - 1;
                    clearInterval(this.#timeOut);
                    return;
                  } else if (this.#loopBreak === true && this.#lock === true) {
                    console.log('Cant merkle start still calculating merkle currently!');
                    console.log('Total File Merkle Loops:', this.#loops);
                    return;
                  } else if (String(this.#theBox.#TrueAnswer).length === 0) {
                    console.log('Cant merkle start still calculating True merkle currently!');
                    return;
                  }
                } catch (err) {
                  console.log('Err:', err);
                  console.log('File Merkle Invalid warning restarting! First Statement!');
                  this.MerkleVerified = 2;
                  this.#theBox.restart(serverFile, serverFolder, interval, merkleInterval, useEnv, devMode, fsMiddleware, consoleOverride, fsOverride);
                  this.#lock = false;
                  return;
                }
              }, merkleInterval);
              this.#lock = false;
              console.timeEnd('Timer');
            }
          } else if (this.#theBox.#TrueAnswerLock === 1 && this.#lock === false && this.#loopBreak === false) {
            if (this.#loops <= 0) {
              this.#lock = true;
              this.#loopBreak = true;
              this.#loops = this.#loops + 1;
              this.#timeOut = setInterval(async () => {
                console.log('File Merkle interval Started! Timeout Interval: 2');
                try {
                  if (this.#theBox.#TrueAnswer && this.#loopBreak === true && this.#lock === false) {
                    this.#lock = true;
                    console.log('Starting File calculations!');
                    if ((v1 === 19 && v2 >= 8) || v1 >= 20) {
                      this.#answer = await this.#hashFolderContentsNodeV22(this.#childcwd);
                    } else {
                      this.#answer = await this.#hashFolderContents(this.#childcwd);
                    }
                    if (this.#answer.firstHash === this.#theBox.#TrueAnswer.firstHash) {
                      this.MerkleVerified = 1;
                      console.log('Verified File Merkle Success!');
                    } else if (this.#answer.firstHash !== this.#theBox.#TrueAnswer.firstHash) {
                      this.MerkleVerified = 2;
                      console.log('File Merkle Invalid warning restarting!');
                      this.#theBox.restart(serverFile, serverFolder, interval, merkleInterval, useEnv, devMode, fsMiddleware, consoleOverride, fsOverride);
                    }
                    this.#lock = false;
                  } else if (this.#loopBreak === false) {
                    console.log('File Merkle Loop Is Breaking! If Server is not restarting please be warned malicious activity may be noticed!');
                    this.#loops = this.#loops - 1;
                    clearInterval(this.#timeOut);
                    return;
                  } else if (this.#loopBreak === true && this.#lock === true) {
                    console.log('Cant merkle start still calculating merkle currently!');
                    console.log('Total File Merkle Loops:', this.#loops);
                    return;
                  } else if (String(this.#theBox.#TrueAnswer).length === 0) {
                    console.log('Cant merkle start still calculating True merkle currently!');
                    return;
                  }
                } catch (err) {
                  console.log('Err:', err);
                  console.log('File Merkle Invalid warning restarting!');
                  this.#theBox.restart(serverFile, serverFolder, interval, merkleInterval, useEnv, devMode, fsMiddleware, consoleOverride, fsOverride);
                  this.#lock = false;
                }
              }, merkleInterval);
              this.#lock = false;
            }
          }
        }

        #nonBlockingTimeout(ms: number): Promise<void> {
          return new Promise((resolve) => {
            setTimeout(resolve, ms);
          });
        }

        async #hashFolderContents(folderPath: string, hashList: any[] = []): Promise<any> {
          const crypto = require('crypto');
          const fs = require('fs');
          const statAsync = fs.promises.stat;
          const readdirAsync = fs.promises.readdir;

          const hash = crypto.createHash('sha256');
          let currentPath: string;
          try {
            const files = await readdirAsync(folderPath);
            for (const file of files) {
              const filePath = `${folderPath}/${file}`;
              currentPath = filePath;
              const stat = await statAsync(filePath);

              if (stat.isDirectory()) {
                const directory = await this.#hashFolderContents(filePath, hashList);
                hash.update(directory.firstHash);
                hashList.push(directory.secondHash);
              } else {
                const fileHex = (await fs.promises.readFile(filePath));
                const obj = {
                  name: file,
                  hash: fileHex
                }
                hashList.push(obj);
                hash.update(fileHex);
              }
            }
            const newAnswer = {
              firstHash: hash.digest('hex'),
              secondHash: hashList
            }
            return newAnswer;
          } catch (err) {
            console.error('Error hashing folder contents:', err);
            console.log('Warning following File is Mismatched!', 'Fs module couldnt Read file it must have been tampered with! Burning and restarting!');
            return null;
          }
        }

        async #hashFolderContentsNodeV22(folderPath: string, hashList: any[] = []): Promise<any> {
          const crypto = require('crypto');
          const fs = require('fs');
          const statAsync = fs.promises.stat;
          const readdirAsync = fs.promises.readdir;

          const hash = crypto.createHash('sha256');
          let currentPath2: string;

          try {
            const files = await readdirAsync(folderPath);

            for (const file of files) {
              const filePath = `${folderPath}/${file}`;
              currentPath2 = filePath;
              const stat = await statAsync(filePath);

              if (stat.isDirectory()) {
                const directory = await this.#hashFolderContentsNodeV22(filePath, hashList);
                hash.update(directory.firstHash);
                hashList.push(directory.secondHash);
              } else {
                const Blob2 = await fs.openAsBlob(filePath);
                const obj = {
                  name: file,
                  hash: Blob2.toString('hex')
                }
                if (this.#theBox.#TrueAnswerLock === 1) {
                  const object = this.#theBox.#TrueAnswer.secondHash.find((value: { name: any; }) => { if (value.name === file) return value; });
                  if (object) {
                    if (object.name === file && object.hash !== obj.hash) {
                      console.log('Warning The following file integrity is at risk!', file, 'Mismatched hashes, Expected Hash:', object.hash, 'Got hash:', obj.hash);
                      return null;
                    }
                  }
                }

                hashList.push(obj);
                const Blob = await fs.openAsBlob(filePath);
                hash.update(Blob.toString('hex'));
              }
            }
            const newAnswer = {
              firstHash: hash.digest('hex'),
              secondHash: hashList
            }
            return newAnswer;
          } catch (err) {
            console.log('Warning following File is Mismatched!', 'Blob couldnt Read file it must have been tampered with');
            console.error('Error hashing folder contents:', err);
            return null;
          }
        }

        async #readFilesRecursively(folder: string, fileList: string[] = []): Promise<string[]> {
          const fs = require('node:fs');
          const path = require('node:path');
          try {
            const files = await fs.promises.readdir(folder);
            for (const file of files) {
              const filePath = path.join(folder, file);
              const stats = await fs.promises.stat(filePath);

              if (stats.isDirectory()) {
                await this.#readFilesRecursively(filePath, fileList);
              } else if (stats.isFile()) {
                fileList.push(filePath);
              }
            }
            return fileList;
          } catch (error) {
            console.error('Error reading files:', error);
            return [];
          }
        }

        async calculateCombinedHash(fileList: string[]): Promise<any> {
          const fs = require('node:fs');
          const path = require('node:path');
          const crypto = require('node:crypto');

          const fileHashes: any[] = [];

          async function calculateHash(filePath: string): Promise<string | undefined> {
            try {
              const data = await fs.promises.readFile(filePath);
              const hash = crypto.createHash('sha256');
              hash.update(data);
              return hash.digest('hex');
            } catch (error) {
              console.log(error);
            }
          }

          try {
            for (const file of fileList) {
              try {
                const filePath = path.join(file);
                if (fs.statSync(filePath).isFile()) {
                  const fileHash = await calculateHash(filePath);
                  const obj = {
                    name: file,
                    hash: fileHash
                  }
                  fileHashes.push(obj);
                }
              } catch (err) {
                console.log('Failed Calculating Hash For:', file, 'Had An Error:', err);
                break;
              }
            }

            const combinedHash = crypto.createHash('sha256');
            combinedHash.update(fileHashes.join(','));
            const answer = {
              firstHash: combinedHash.digest('hex'),
              secondHash: fileHashes
            };
            return answer;
          } catch (e) {
            console.log(e);
            return;
          }
        }

        setGlobal(JBGlobal: any) {
          this.#JBGlobal = JBGlobal;
        }

        getMerkleVerify(): number {
          return this.MerkleVerified;
        }

        terminate() {
          clearInterval(this.#timeOut);
          this.#loopBreak = false;
          this.#lock = true;
        }

        toggleLock() {
          this.#lock3 = true;
        }

        getProtectorLock3(): boolean {
          return this.#lock3;
        }
      }
      return new TheProtectorC(serverFile, serverFolder, interval, merkleInterval, useEnv, devMode, fsMiddleware, consoleOverride, fsOverride, childCWD, theBox);
    }

    terminate() {
      this.#breakValue = false;
      this.#child.emit(this.#GlobalReference.getGlobalString());
      this.#child.kill();
      console.log('Chiled: ', this.#child.killed);
      console.log(this.#child.exitCode, 'Child exit code');
      this.#TheProtectorO.terminate();
      clearTimeout(this.#timeOut);
    }

    restart(serverFile: string, serverFolder: string, interval: number, merkleInterval: number, useEnv: boolean, devMode: boolean, fsMiddleware: boolean, consoleOverride: any, fsOverride: any) {
      if (this.#TheProtectorO.getProtectorLock3() === false) {
        console.log('Restarting with:', serverFile, serverFolder, interval, useEnv, devMode, fsMiddleware, consoleOverride, fsOverride);
        this.terminate();
        return new GodBox(serverFile, serverFolder, interval, merkleInterval, useEnv, devMode, fsMiddleware, consoleOverride, fsOverride);
      }
    }

    stop() {
      const fs = require('node:fs');
      try {
        fs.rmSync(this.#childcwd, { recursive: true, retryDelay: 1000, maxRetries: 10 });
      } catch (err) {
      }
      this.terminate();

      return;
    }
}

export { GodBox };
module.exports = { GodBox };